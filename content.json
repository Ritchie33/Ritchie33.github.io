{"meta":{"title":"Ritchie's blog","subtitle":null,"description":"Ritchie's blog","author":"Ritchie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-08-16T09:48:21.000Z","updated":"2019-08-16T09:50:07.512Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-16T09:48:46.000Z","updated":"2019-08-16T09:50:28.991Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS 外边距重叠及防止方法","slug":"CSS-外边距重叠及防止方法","date":"2019-08-20T08:39:18.000Z","updated":"2019-08-20T08:42:27.214Z","comments":true,"path":"2019/08/20/CSS-外边距重叠及防止方法/","link":"","permalink":"http://yoursite.com/2019/08/20/CSS-外边距重叠及防止方法/","excerpt":"","text":"两个或多个块级盒子的垂直相邻边界会重合。结果的边界宽度是相邻边界宽度中最大的值。如果出现负边界，则在最大的正边界中减去绝对值最大的负边界。如果没有正边界，则从零中减去绝对值最大的负边界。注意：相邻的盒子可能并非是由父子关系或同胞关系的元素生成。 但是边界的重叠也有例外情况： 1、水平边距永远不会重合。 2、在规范文档中，2个或以上的块级盒模型相邻的垂直margin会重叠。最终的margin值计算方法如下： a、全部都为正值，取最大者； b、不全是正值，则都取绝对值，然后用正值减去最大值； c、没有正值，则都取绝对值，然后用0减去最大值。 注意：相邻的盒模型可能由DOM元素动态产生并没有相邻或继承关系。 3、相邻的盒模型中，如果其中的一个是浮动的（float），垂直margin不会重叠，并且浮动的盒模型和它的子元素之间也是这样。 4、设置了overflow属性的元素和它的子元素之间的margin不被重叠（overflow取值为visible除外）。 5、设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，并且和他们的子元素之间也是一样。 6、设置了display:inline-block的元素，垂直margin不会重叠，甚至和他们的子元素之间也是一样。 7、如果一个盒模型的上下margin相邻，这时它的margin可能重叠覆盖（collapse through）它。在这种情况下，元素的位置（position）取决于它的相邻元素的margin是否重叠。 a、如果元素的margin和它的父元素的margin-top重叠在一起，盒模型border-top的边界定义和它的父元素相同。 b、另外，任意元素的父元素不参与margin的重叠，或者说只有父元素的margin-bottom是参与计算的。如果元素的border-top非零，那么元素的border-top边界位置和原来一样。 一个应用了清除操作的元素的margin-top绝不会和它的块级父元素的margin-bottom重叠。 注意，那些已经被重叠覆盖的元素的位置对其他已经重叠的元素的位置没有任何影响；只有在对这些元素的子元素定位时，border-top边界位置才是必需的。 8、根元素的垂直margin不会被重叠。 外边距(margin)重叠示例 外边距重叠是指两个垂直相邻的块级元素，当上下两个边距相遇时，起外边距会产生重叠现象，且重叠后的外边距，等于其中较大者。 图示： 另一个重叠现象是当一个元素包含在另一个元素之中时，子元素与父元素之间也会产生重叠现象，重叠后的外边距，等于其中最大者： CSS 外边距(margin)重叠及防止方法 同理，如果一个无内容的空元素，其自身上下边距也会产生重叠。 CSS 外边距(margin)重叠及防止方法 外边距重叠的意义 外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。 防止外边距重叠解决方案： 虽然外边距的重叠有其一定的意义，但有时候我们在设计上却不想让元素之间产生重叠，那么可以有如下几个建议可供参考： 1234561.外层元素padding代替2.内层元素透明边框 border:1px solid transparent;3.内层元素绝对定位 postion:absolute:4.外层元素 overflow:hidden;5.内层元素 加float:left;或display:inline-block;6.内层元素padding:1px; 以上建议可根据实际情况来采取。","categories":[],"tags":[]},{"title":"笔记3","slug":"笔记3","date":"2019-08-19T00:48:15.000Z","updated":"2019-08-21T08:36:39.186Z","comments":true,"path":"2019/08/19/笔记3/","link":"","permalink":"http://yoursite.com/2019/08/19/笔记3/","excerpt":"","text":"1.设置透明opacity可以设置元素背景的透明，规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 注：opacity属性在IE8及以下的浏览器中不支持，需要使用alpha属性代替，从 0（完全透明）到 100（完全不透明）。 2.图片整合技术当做一个按钮时，有时需要不同的鼠标点击效果，设置伪类切换背景图片从而改变样式。 但是做完功能以后，发现在第一次切换图片时，会发现图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。 产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源。 上面这个练习，起初浏览器只会加载link.png由于hover和active的状态没有马上触发，所以hover.png和active.png并不是立即加载的当hover被触发时，浏览器才去加载hover.png。当active被触发时，浏览器才去加载active.png。 由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况。 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了， 然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术。 优点： 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。 3. 内联元素的盒模型内联元素不能设置width和height。 内联元素可以设置水平方向内边距和边框且可以影响布局； 内联元素可以设置垂直方向内边距和边框但不可以影响布局； 内联元素支持水平方向外边距且可以影响布局； 内联元素不支持垂直方向外边距； 4. display通过display样式可以改变元素的类型 可选值： Inline：此元素会被显示成内联元素。 Block：此元素会被显示成块元素（可换行）。 Inline-block：此元素会被显示成行内块元素（既可以设置宽高也不会换行）。 None：不显示元素，并且元素不会在页面中继续占有位置。 5. overflow子元素默认是存在于父元素的内容区内，理论上讲子元素最大可以等于父元素的内容区大小。 实际如果子元素的大小超过了父元素的内容区，则超过的大小会在父元素以外的位置显示，超出父元素的内容，我们称为溢出的内容。父元素默认是将溢出内容在父元素外显示。 通过overflow可以设置父元素如何处理溢出内容。 可选值： Visible：默认值，不会对溢出内容做处理，元素在父元素内容区外显示。 Hidden：溢出的内容会被修剪，不会显示。 6. clearClear可以用来清除其他浮动元素对当前元素的影响 可选值： none：默认值，不清除浮动。 left：清除左侧浮动元素对当前元素的影响。 right：清除右侧浮动元素对当前元素的影响。 both：清除两侧浮动元素对当前元素的影响。 7.解决高度塌陷方案可以直接在高度塌陷的父元素最后添加一个空白的div，由于这个div没有浮动，所以他是可以撑开父元素的高度的，然后再对其进行清除浮动，这样可以通过空白的div来撑开父元素的高度，基本没有副作用。 这种方式虽然可以解决高度塌陷但是会在HTML中添加多余的结构。 可以通过after伪元素在父元素的最后添加一个空白的元素，然后对其清除浮动。 由于after在元素最后插入生成的内容为行内元素，行内元素不会独占一行，所以需要先使用display将其改为块元素再对其清除浮动。 这样做和添加一个div的原理一样，可以达到相同的效果，而且不会再页面中添加多余的div，几乎没有副作用，这是最推荐的解决高度塌陷问题的方式。 例： 12345678910.box1:after&#123; /*添加一个内容*/ content:\"\"; /*转换为一个块元素*/ display:block; /*清除两侧的浮动*/ clear:both; &#125; 8.表单表单用于收集用户输入，表单的作用就是用来将用户信息提交给服务器的。比如：百度的搜索框 注册 登录这些操作都需要填写表单。 8.1 action属性action属性定义在提交表单时执行的动作。使用form标签创建一个表单，form标签中必须指定一个action属性，该属性指向的是一个服务器的地址。当我们提交表单时将会提交到action属性对应的地址，向服务器提交表单的通常做法是使用提交按钮。 1&lt;form action=&quot;action_page.php&quot;&gt; 8.2 method属性method属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）： 1&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt; 或： 1&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt; 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。 当使用 GET 时，表单数据在页面地址栏中是可见的。 注：GET 最适合少量数据的提交。浏览器会设定容量限制。 应该使用 POST： 如果表单正在更新数据，或者包含敏感信息（例如密码）。 POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 8.3 文本输入&lt; input type=”text”&gt; 定义用于文本输入的单行输入字段。使用input来创建一个文本框，它的type属性是text。 8.4 提交按钮&lt; input type=”submit”&gt;定义用于向表单处理程序（form-handler）提交表单的按钮。 表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。表单处理程序在表单的 action 属性中指定。 8.5 name属性如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性，name表示提交内容的名字。 8.6 用 fieldset 组合表单数据fieldset 元素组合表单中的相关数据 legend 元素为 fieldset元素定义标题。 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset 中。在fieldset可以使用legend子标签，来指定组名。 其余表单内容详见：https://www.w3school.com.cn/html/html_form_elements.asp","categories":[],"tags":[]},{"title":"笔记2","slug":"笔记2","date":"2019-08-17T01:56:17.000Z","updated":"2019-08-17T12:51:15.374Z","comments":true,"path":"2019/08/17/笔记2/","link":"","permalink":"http://yoursite.com/2019/08/17/笔记2/","excerpt":"","text":"1.定位通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。 position 属性值的含义： 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素（离他最近的开启了定位的祖先元素）进行定位。元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。（会固定在浏览器窗口某个位置，不会随浏览器滚动条滚动）。 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。相对定位会使元素提升一个层级。 因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 2.层级如果定位元素层级一样，html中下边的元素会盖住上面的元素。 z-index通过z-index属性可以设置元素的层级，层级越高，显示离用户越近。（z-index 仅能在定位元素上奏效）","categories":[],"tags":[]},{"title":"笔记1","slug":"笔记1","date":"2019-08-16T08:56:45.000Z","updated":"2019-08-16T08:57:37.854Z","comments":true,"path":"2019/08/16/笔记1/","link":"","permalink":"http://yoursite.com/2019/08/16/笔记1/","excerpt":"","text":"Ajax理解Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。比如在知乎页面中将鼠标悬停到标签上时创建一个新的小窗口，用js向知乎服务器发送一个请求，得到这个小窗口应该显示的数据，放在这个小窗口里，这就是所谓的Ajax，不用刷新就能与服务器进行交互，更新页面的一小部分。例如，门户网站的新闻列表，可能1个小时之内，服务器后台已增加了很多条新的新闻，前端可以通过刷新，从新获取最新的新闻展示在页面上。 再如，网页文字直播NBA篮球比赛，可能后台服务器每几秒就会有一条新的动态，需要用户连续刷新页面内容来获取最新动态。以上的刷新方法是用户手动对整个页面内容进行刷新，针对以上的需求，明显是不合理的，AJAX就是实现了自动更新需要刷新的数据的效果。其基本思路是前端js与后台不断通讯,及时获取前端某部分数据的变化信息,及时进行自动数据获取更新,使用户无需刷新网页即可保持页面数据最新的状态。例如，球赛文字直播、股票实时信息等。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-16T06:41:27.267Z","updated":"2019-08-16T06:41:27.267Z","comments":true,"path":"2019/08/16/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}