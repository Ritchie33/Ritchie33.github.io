{"meta":{"title":"Ritchie's blog","subtitle":null,"description":"Ritchie's blog","author":"Ritchie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-16T09:48:46.000Z","updated":"2019-08-16T09:50:28.991Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-16T09:48:21.000Z","updated":"2019-08-16T09:50:07.512Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mongoose","slug":"mongoose笔记","date":"2020-03-06T01:01:59.000Z","updated":"2020-03-05T16:13:22.027Z","comments":true,"path":"2020/03/06/mongoose笔记/","link":"","permalink":"http://yoursite.com/2020/03/06/mongoose笔记/","excerpt":"","text":"1.MongoDB 数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合 一个集合中可以有多个文档 文档结构很灵活，没有任何限制 MongoDB 非常灵活 当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 一切都由MongoDB来自动完成建库建表这件事 12345678910111213141516171819202122232425262728&#123; //qq数据库 qq:&#123; //qq数据库中的users集合 users: [ //users集合中的文档 &#123;name: 'ritchie', age: 23&#125;, &#123;name: '孔祥姗', age: 3&#125;, &#123;name: '王琦', age: 23&#125;， ... ], //qq数据库中的products集合 products:[ ... ] &#125;, //淘宝数据库 taobao:&#123; ... &#125;, //百度数据库 baidu:&#123; ... &#125;&#125; 2.起步安装： 1npm i mongoose hello world: 1234567891011121314var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/test',&#123; useMongoClient: true&#125;)var Cat = mongoose.model('Cat',&#123; name:String &#125;)var kitty = new Cat(&#123; name: 'kxs' &#125;)kitty.save(function (err) &#123; if (err) &#123; console.log(err) &#125; else&#123; console.log('喵喵喵') &#125;&#125;) 3.官方指南3.1. 设计 Schema 发布 Model123456789101112131415161718192021222324252627282930313233343536var mongoose = require('mongoose')// 1.连接数据库// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongoose://localhost/itcast')var Schema = mongoose.Schema// 2.设计文档结构// 字段名称就是表结构中的属性名称// 约束的目的是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username: &#123; type: String, require: true //必须有 &#125;, password: &#123; type: String, require: true &#125;, email: &#123; type: String default: 'xxx@qq.com' //默认值 &#125;&#125;)// 3.将文档结构发布为模型// mongoose.model 方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称、// mongoose会自动将大写名词的字符串生成小写复数的集合名称// 例如这里的User最终会变成users集合名称// 第二个参数：架构Schemavar User = mongoose.model('User', userSchema)// 4.当我们有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据为所欲为了（增删改查） 3.2. 增加数据12345678910111213var admin = new User(&#123; username: 'admin', password: '123456', email: 'admin@admin.com'&#125;)admin.save(function (err, ret) &#123; if (err) &#123; console.log('保存失败') &#125; else &#123; console.log('保存成功') &#125;&#125;) 3.3. 查询查询所有： 1234567User.find(function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;) 按条件查询所有： 123456789User.find(&#123; username: 'zs' &#125;, function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;) 按条件查询单个： 123456789User.findOne(&#123; username: 'zs' &#125;, function (err, ret) &#123; if (err) &#123; console.log('查询失败') &#125; else &#123; console.log(ret) &#125;&#125;) 3.4. 更新数据根据条件更新所有： 123Model.update(conditions, docs, options, callback)//conditions 条件//docs 更新的内容 根据指定条件更新一个： 1Model.findOneAndUpdate(conditions, docs, options, callback) 根据id更新一个： 123456789User.findByIdAndUpdate('5a001b23d219eb00c8581186', &#123; username: 'zs' &#125;, function (err, ret) &#123; if (err) &#123; console.log('更新失败') &#125; else &#123; console.log('更新成功') &#125;&#125;) 3.5. 删除数据根据条件删除所有： 123456789User.remove(&#123; username: 'zs' &#125;, function (err, ret) &#123; if (err) &#123; console.log('删除失败') &#125; else &#123; console.log('删除成功') &#125;&#125;) 根据条件删除一个： 1Model.findOneAndRemove(conditions, options, callback) 根据id删除一个： 1Model.findByIdAndRemove(id, options, callback)","categories":[],"tags":[]},{"title":"Express","slug":"Express","date":"2020-03-06T01:01:58.000Z","updated":"2020-03-05T16:13:00.582Z","comments":true,"path":"2020/03/06/Express/","link":"","permalink":"http://yoursite.com/2020/03/06/Express/","excerpt":"","text":"Express原生的http在某些方面不足以应对我们的开发需求，所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码更高度统一。 在Node中，有很多Web开发框架，这里以express为主。 http://expressjs.com/ 1. 起步1.1. 安装：1npm install --save express 1.2. hello world:12345678910111213var express = require('express')// 创建 appvar app = express()// 设置请求处理函数app.get('/', function (req, res) &#123; res.send('hello world')&#125;)app.listen(3000, function&#123; console.log('express app is running...') &#125;) 1.3. 基本路由get: 1234// 以 GET 方法请求 / 的时候，执行对应的处理函数app.get('/', function (req, res) &#123; res.send('hello world')&#125;) post: 1234// 以 POST 方法请求 / 的时候，执行对应的处理函数app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) ##### 1.4. 静态服务12345678910111213141516171819202122//个人理解：//浏览器向服务器发请求，服务器返回响应//浏览器收到HTML响应内容之后，就要开始从上到下依次解析//在解析的过程中遇到：//link,script,img,iframe,video,audio等具有src或者href属性标签（具有外链的资源）的时候//浏览器会对这些资源发起新的请求，每一个具有外链的资源都是一个新的请求//也就是一张图片或一个css文件都会向服务器发送新的请求//我们为了方便的统一处理这些静态资源，所以可以把所有的静态资源都放在public目录中//例如css、img、js、第三方包等// 直接访问public中的资源// /public资源app.use(express.static('public'));// 当以 /public/ 开头的时候， 去./public/ 目录中查找对应的资源// /public/xxxapp.use('/public/' , express.static('./public/'));// 当以 /views/ 开头的时候， 去./views/ 目录中查找对应的资源// /views/xxxapp.use('/views/' , express.static('./views/')); 2. 在Express中使用art-template模板引擎安装： 12npm install --save art-templatenpm install --save express-art-template 配置： 12345// express-art-template 是专门用来在express中把art-template整合到express中的// art-template必须安装，因为express-art-template依赖了art-template// 第一个参数表示，当渲染以.html结尾的文件时，使用art-template模板引擎app.engine('html', require('express-art-template')) 使用： 1234567891011121314151617// Express为 Response提供了一个方法：render// render 方法默认是不可以使用的，但是如果配置了模板引擎就可以是使用了// res.render('文件名',&#123;模板数据&#125;)// 第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件// Express有一个约定：开发人员把所有的视图文件都放到 views 目录中app.get('/', function (req, res) &#123; res.render('index.html', &#123; titile: '首页' //用'首页'替换index.html中的&#123;&#123; title &#125;&#125; &#125;)&#125;)// 假设要渲染views文件中的admin文件夹中的xxx.html// 记住不要写viewsapp.get('/admin', function (req, res) &#123; res.render('/admin/xxx.html')&#125;) 3.表单请求体数据12345678910&lt;!-- action 就是表单提交的地址，说白了就是请求的url地址 method 请求方法 get post--&gt;&lt;form action = \"app.js\" method = \"get\"&gt; &lt;!--表单中需要提交的表单控件元素必须具有name属性--&gt; ...&lt;/form&gt; 表单GET请求体数据//Express内置了一个API，可以直接通过req.query来获取 12345678app.get('/', function (req, res) &#123; // 1. 获取表单 GET 请求体数据 // 2. 处理 // 3. 发送响应 // 可以通过 req.query 来获取 get 请求体数据 console.log(req.query)&#125;) 表单POST请求体数据在 Express 中没有内置获取表单 POST 请求体的 API，这里我们需要使用一个第三方包：body-parser。 安装： 1npm install --save body-parser 配置： 12345678910111213var express = require('express')// 1. 引包var bodyParser = require('body-parser')var app = express()// 2. 配置 body-parser// 只要加入这个配置，则在 req 请求对象上会多出一个属性：body// 也就是说可以直接通过 req.body 来获取表单 POST 请求体数据了app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 使用： 1234app.post('/', function (req, res) &#123; // 通过 req.body 来获取表单 POST 请求体数据 console.log(req.body)&#125;) 4.CRUD起步4.1. 起步 初始化 安装依赖 模板处理 4.2. 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name、age、gender、hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id、name、age、gender、hobbies 处理编辑请求 GET /students/delete id 处理删除请求 4.3. 提取路由模块router.js文件 12345678910111213141516171819202122232425262728293031323334/* router.js路由模块 职责： 处理路由 根据不同的请求方法+请求路径设置具体的请求处理函数 模块职责要单一，不要乱写 划分模块的目的就是为了增强项目代码的可维护性 提升开发效率*/var express = require('express')// Express 提供了一种很好的方式// 专门用来包装路由// 1. 创建一个路由容器var router = express.Router()// 2. 把路由容器都挂载到 router 路由容器中router.get('/students',function (req, res) &#123; ...&#125;)router.get('/students/new', function (req, res) &#123; ...&#125;)router.post('/students/new', function (req, res) &#123; ...&#125;)...// 3. 把 router 导出module.exports = router app.js文件 12345678910111213141516var express = require('express')// 加载router.js文件，获取到router.js中的routervar router = require('./router')var app = express()app.use('/public/' , express.static('./public/'));app.use('/node_modules/' , express.static('./node_modules/'));// 把路由容器挂载到 app 服务中app.use(router)app.listen(3000, function () &#123; console.log('running 3000...')&#125;) 4.4. 设计操作数据的 API 文件模块student.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/* student.js 数据操作文件模块 职责：操作文件中的数据，只处理数据，不关心业务*/var fs = require('fs')var dbPath = './db.json'// 获取所有学生列表// return []/* callback 中的参数 第一个参数是 err 成功是 null，错误是 错误对象 第二个参数是结果 成功是 数组， 错误是 undefined*/exports.find = function (callback) &#123; fs.readFile(dbPath, 'utf8', function (err, data) &#123; if (err) &#123; return callback(err) &#125; // data是db.json文件字符串 // JSON.parse(data) 将字符串转换成对象 // JSON.parse(data).students 就是对象中的students callback(null, JSON.parse(data).students) &#125;)&#125;// 在router.js文件中调用find方法/*var Student = require('./student')router.get('/students', function (req, res) &#123; Student.find(function (err, students) &#123; if (err) &#123; return res.send('Server error') &#125; res.render('index.html', &#123; students: students &#125;) &#125;)&#125;)*/// 添加保存学生exports.save = function (student, callback) &#123; fs.readFile(dbPath, 'utf8', function (err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 处理 id 唯一的，不重复 student.id = students[students.length - 1].id + 1 // 把用户传递的对象保存到数组中 students.push(student) // 把对象数据转换为字符串 var fileData = JSON.stringfy(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function (err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125;// 在router.js文件中调用save方法/*router.post('/students/new', function (req, res) &#123; Student.save(req.body, function (err) &#123; if (err) &#123; return res.send('Server error.') &#125; res.redirect('/students') &#125;)&#125;)*/// 更新学生exports.updateByID = function (student, callback) &#123; fs.readFile(daPath, 'utf8', function (err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // 要修改谁，就需要把谁找出来 // ES6 中的一个数组方法：find // 需要接收一个函数作为参数 // 当某个便利项符合 item.id === student.id 条件的时候，find会终止遍历，同时返回遍历 var stu = students.find(function (item) &#123; return item.id === students.id &#125;) // 遍历拷贝对象 for (var key in student) &#123; stu[key] = student[key] &#125; // 把对象数据转换为字符串 var fileData = JSON.stringfy(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function (err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125;// 删除学生exports.deleteByID = function (id, callback) &#123; fs.readFile(dbPath, 'utf8', function (err, data) &#123; if (err) &#123; return callback(err) &#125; var students = JSON.parse(data).students // findIndex 方法专门用来根据条件查找元素的下标 var deleteID = students.findIndex(function (item) &#123; return item.id === parseInt(id) &#125;) // 根据下标从数组中删除对应的学生对象 students.splice(deleteID, 1) // 把对象数据转换为字符串 var fileData = JSON.stringfy(&#123; students: students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath, fileData, function (err) &#123; if (err) &#123; // 错误就是把错误对象传递给它 return callback(err) &#125; // 成功就没错，所以错误对象是 null callback(null) &#125;) &#125;)&#125;","categories":[],"tags":[]},{"title":"React","slug":"React","date":"2020-03-06T01:01:57.000Z","updated":"2020-03-05T16:12:26.876Z","comments":true,"path":"2020/03/06/React/","link":"","permalink":"http://yoursite.com/2020/03/06/React/","excerpt":"","text":"React1. React中的几个核心的概念虚拟DOM DOM的本质是什么：浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API; 什么是React中的虚拟DOM：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套； 为什么要实现虚拟DOM（虚拟DOM的目的）：为了实现页面中，DOM元素的高效更新； DOM和虚拟DOM的区别： DOM：浏览器中提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API； 虚拟DOM：是框架中的概念；是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系； 本质：用JS对象，来模拟DOM元素和嵌套关系； 目的：就是为了实现页面元素的高效更新； Diff算法 tree diff：新旧两颗DOM树，逐层对比的过程，就是Tree Diff；当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到； component diff：在进行Tree Diff的时候，每一层中，组件级别的对比，叫做Component Diff； 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。 如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上； element diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做Element Diff； 2.模块化和组件化 什么是组件：组件的出现就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； 什么是模块化：是从 代码 的角度来进行分析的；方便代码分层开发，保证每个功能模块的职能单一；把一些可复用的代码，抽离为单个的模块；便于项目的维护和开发； 什么是组件化：是从 UI界面 的角度来进行分析的；前端的组件化，方便UI组件的重用；把一些可复用的UI元素，抽离为单独的组件；便于项目的维护和开发； 组件化的好处：随着项目规模的增大，手里的组件越来越多，很方便就把现有的组件，拼接为一个完整的页面； Vue是如何实现组件化的：通过.vue文件，来创建对应的组件； template 结构 script 行为 style 样式 React如何实现组件化：React中有组件化的概念，但是并没有像vue这样的组件模板文件；React中，一切都是以JS来表现的； 3. Webpack3.1 创建基本的webpack4.x项目 快速初始化项目 1npm init -y 在项目根目录创建src源代码目录和dist产品目录 在src目录下创建index.html和index.js 使用cnpm安装webpack 1cnpm i webpack webpack-cli -D 注意：webpack4.x之后webpack命令行都是有webpack-cli来提供了。 在项目根目录下创建配置文件webpack.config.js 123module.exports = &#123; mode: 'development' // development（开发模式）或 production（生产模式）&#125; 运行webpack进行将index.js打包输出 1webpack 注意：webpack4.x提供了约定大于配置的概念；目的是为了尽量减少配置文件的体积； 默认约定了： 打包的入口是src -&gt; index.js 打包的输出文件是dist -&gt; main.js 4.x 中新增了 mode选项（为必选项），可选的值为：development和production； 3.2 webpack-dev-server 每次更改完代码都需要重新运行webpack打包，而且还需要手动刷新浏览器。webpack-dev-server可以解决这个问题。 安装webpack-dev-server 1npm i webpack-dev-server-D 打开配置package.json文件 123\"scripts\": &#123; \"dev\": \"webpack-dev-server --open\" // --open表示自动打开页面&#125; 运行 1npm run dev 这样每次更改完代码保存后，都会自动进行打包生成新的main.js文件。 注意：启动webpack-dev-server后，你在目标文件夹中是看不到编译后的文件的,实时编译后的文件都保存到了内存当中。我们可以认为在项目根目录中有一个看不见的main.js。 3.3 html-webpack-pluginhtml-webpack-plugin可以帮我们将页面生成到内存中 安装 1npm i html-webpack-plugin -D 配置文件webpack.config.js 123456789101112131415const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')// 创建一个插件的实例对象const htmlPlugin = new HtmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), // 源文件 filename: 'index.html' // 生成在内存中首页的名称&#125;)module.exports = &#123; mode: 'development', plugins: [ htmlPlugin ]&#125; 注意：html-webpack-plugin会自动将打包好的main.js引入到index.html中，所以不需要在index.html中手动引入。 4. 在项目中使用React 安装包 1npm i react react-dom -S react：专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包里 react-dom：专门进行DOM操作的，最主要的应用场景，就是ReactDOM.render() 在index.html页面中，创建容器： 12&lt;!-- 容器，将来使用React创建的虚拟DOM元素，都会被渲染到这个指定的容器中--&gt;&lt;div id = \"app\"&gt;&lt;/div&gt; 导入包 12345/*index.js*/// 这两个导入的时候，接受的成员名称必须这么写import React from 'react' // 创建组件、虚拟DOM元素、生命周期import ReactDOM from 'react-dom' // 把创建好的组件和虚拟DOM放到页面上展示 创建虚拟DOM元素 123456789/*index.js*/// 这是创建虚拟DOM元素的 API// 第一个参数：字符串类型的参数，表示要创建的标签的名称// 第二个参数：对象类型的参数，表示创建的元素的属性节点// 第三个参数：子节点（包括其他虚拟DOM、或文本子节点）// &lt;h1 title = \"啊，五环\" id = \"myh1\"&gt;你比四环多一环&lt;/h1&gt;const myh1 = React.createElement('h1', &#123; title:'啊，五环', id:'myh1' &#125;, '你比四环多一环') 渲染 123456/*index.js*/// 渲染虚拟DOM元素// 第一个参数：表示要渲染的虚拟DOM对象// 第二个参数：指定容器，注意：这里不能直接放元素容器的id字符串，需要放一个容器的DOM对象ReactDOM.render(myh1, document.getElementById('app')) 8. JSX语法 什么是JSX语法：就是符合 xml 规范的 JS 语法；（语法格式相对来说要比HTML严谨很多） 如何启用JSX语法？ 安装babel插件 1cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 1cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换 JSX 语法的包babel-preset-react 1cnpm i babel-preset-react -D 添加.babelrc配置文件 1234&#123; \"presets\": [\"env\", \"stage-0\", \"react\"], \"plugins\": [\"transform-runtime\"]&#125; 添加babel-loader配置项： 1234567// webpack-config.jsmodule: &#123; // 所有第三方模块的配置规则 rules: [ // 第三方匹配规则 &#123; test: /\\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/ &#125;, ]&#125;","categories":[],"tags":[]},{"title":"vue笔记1","slug":"vue笔记1","date":"2019-09-06T09:07:06.000Z","updated":"2020-03-05T16:08:32.796Z","comments":true,"path":"2019/09/06/vue笔记1/","link":"","permalink":"http://yoursite.com/2019/09/06/vue笔记1/","excerpt":"","text":"1.Vue简介vue是一个渐进式Javascript框架，可以自底向上逐层应用。 vue直接通过&lt;script&gt;标签进行引入，可以通过下载vue.js文件的方式引入或者直接引入CDN（如下）进行使用。 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 2.创建第一个vue实例 1 直接通过new Vue()创建一个vue的实例，可以传递一个参数{}给这个实例。 双括号：插值表达式 挂载点：vue中的el（element）指向标签的id，图中标签就叫做vue的挂载点。vue只会处理挂载点中的内容。 模板：模板指的就是挂载点内部的内容，可以写在挂载点内部，也可以写在vue中的template属性中。 3.Vue实例中的数据，事件和方法下图中vue的指令v-text和v-html可以把content变量通过文本和html的不同方式显示。 2 v-on该模板指令表示要绑定一个事件，下图中绑定的是click事件，该事件触发的时候调用了一个函数，这个函数要写在Vue实例中的methods对象中，点击Hello World后变成Vue。 4","categories":[],"tags":[]},{"title":"git笔记2","slug":"git笔记2","date":"2019-09-04T01:01:57.000Z","updated":"2019-09-04T11:46:52.624Z","comments":true,"path":"2019/09/04/git笔记2/","link":"","permalink":"http://yoursite.com/2019/09/04/git笔记2/","excerpt":"","text":"删除文件rm命令用于删除文件1$ rm test.txt $ rm test.txt用于删除工作区中的文件 1$ git rm test.txt $ git rm test.txt用于删除版本库中的文件 如果不小心删错了工作区中的文件，还可以用git checkout来恢复文件，git checkout就是将版本库中的版本拷贝到工作区中。 注：文件如果没有添加到版本库中就被删除则无法恢复。 添加远程库1$ git remote add origin git@github.com:ritchie33/learngit.git 将远程库与本地关联1$ git push -u origin master 第一次把本地master分支的内容推送到远程1$ git push origin master 把本地master分支推送到远程 从远程库克隆1$ git clone git@github.com:ritchie33/gitskills.git 把远程库克隆到本地 创建与合并分支创建并切换分支1$ git checkout -b 分支名 创建分支1$ git branch 分支名 切换分支1$ git checkout 分支名 查看当前分支1$ git branch 合并指定分支到当前分支1$ git merge 分支名 删除分支1$ git branch -d 分支名 注：在一个分支上（图中的dev）做修改，只有add、commit之后这个分支才会像图里描述的那样前进一步，告诉Git新增了一个版本。 1567586338855 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交，合并完成。 查看分支合并图1$ git log --graph --pretty=oneline --abbrev-commit --pretty=oneline：输出版本只显示一行 --abbrev-commit：版本号只显示前几个字符 以下图片解释不同： 1567587299483 1567587382529 1567587437486 分支管理策略用no fast forward模式合并分支1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 1567595003000 分支策略一般情况下master分支都是用来发布新版本的，工作都在dev分支上，每个员工都有自己的分支，时不时往dev分支合并，最后要发布新版本时再将dev合并到master上，在master上发布新版本。 Bug分支将当前工作现场储存1$ git stash 回到工作现场并删除stash1$ git stash pop 查看stash内容1$ git stash list 复制某次特定的提交到当前分支1$ git cherry-pick 版本号 用git cherry-pick 版本号命令，把bug提交的修改复制到当前分支，避免重复劳动。 Feature分支开发一个新功能一般会新建一个feature分支，在feature分支上开发，开发完成后与dev分支合并，最后删除feature分支。 强行删除1$ git branch -D 分支名 如果要丢弃一个没有合并的分支，需要用git branch -D 分支名指令强行删除。 详见：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[],"tags":[]},{"title":"git笔记","slug":"git笔记","date":"2019-08-30T05:48:41.000Z","updated":"2019-08-30T10:48:39.921Z","comments":true,"path":"2019/08/30/git笔记/","link":"","permalink":"http://yoursite.com/2019/08/30/git笔记/","excerpt":"","text":"指定用户名和email地址12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注：git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置。 创建版本库123$ mkdir learngit$ cd learngit$ pwd pwd命令用于显示当前目录。 git init命令可以把这个目录变成Git可以管理的仓库1$ git init 创建一个文件1$ vi readme.txt 把一个文件放到Git仓库需要两步。第一步，用命令git add把文件添加到仓库：1$ git add readme.txt 第二步，用命令git commit把文件提交到仓库：1$ git commit -m &quot;wrote a readme file&quot; git commit命令，-m后面输入这次提交的备注，比如做出了什么修改。 小结1使用git init命令把这个目录变成Git可以管理的仓库。 添加文件到Git仓库有两步： git add &lt;file&gt; git commit -m &lt;message&gt; git status命令告知我们仓库当前的状态1$ git status git diff查看修改了什么内容，diff就是difference1$ git diff readme.txt 小结2 使用git status命令查看当前仓库的状态。 如果git status告知文件被修改过，用git diff可以查看修改内容。 用git log命令查看历史记录,git log命令从最近到最远显示1$ git log 加上--pretty=oneline参数可以简化历史记录便于我们查看1$ git log --pretty=oneline 使用git reset命令返回到之前的版本1$ git reset --hard HEAD^ HEAD表示当前版本，上一个版本就是HEAD^，前第100个版本写成HEAD~100。 git reflog记录每一次命令1$ git reflog 小结3 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 ##### 工作区就是在电脑中的目录，learngit文件夹就是一个工作区。 版本库隐藏目录.git，是Git的版本库。 暂存区下图中的stage就是暂存区。 前面把文件添加到Git的版本库中第一步是用git add命令，实际上就是把文件的修改添加到暂存区；第二步是用git commit命令，实际就是把暂存区里的所有内容全部提交到master分支。 可以理解为文件修改全部放到暂存区，然后一次性提交暂存区的所有修改。 小结4git add命令实际上就是把要提交的所有修改放到暂存区，然后执行git commit就可以一次性把暂存区的所有修改提交到分支。 管理修改如果要提交两次或多次修改，可以先进行第一次修改，然后使用git add命令将第一次修改放到暂存区，然后再进行第二次修改，再使用git add命令将第二次修改放到暂存区，以此类推，最后使用git commit命令提交到分支。 注：一定要将文件的修改git add后才可以使用git commit，因为git commit是将暂存区的文件修改提交到分支的，如果修改了文件但没有将文件修改使用git add添加到暂存区，则修改不会被提交到分支。 小结5第一次修改 –&gt; git add –&gt; 第二次修改 –&gt; git add –&gt; … –&gt; git commit 撤销修改1$ git checkout -- readme.txt git checkout --readme.txt指的是把readme.txt文件在工作区的修改撤销。 1$ git reset HEAD readme.txt git reset HEAD readme.txt指的是把readme.txt文件在暂存区的修改撤销。 小结6 如果对文件进行了修改还没有git add到暂存区，可以使用git checkout --readme.txt撤销工作区的修改。 如果对文件进行了修改且git add到暂存区了，可以使用git reset HEAD readme.txt撤销暂存区的修改。 如果对文件进行了修改git add到了暂存区，且使用git commit提交到了分支，可以使用git reset命令返回到之前的版本。 详见：https://www.liaoxuefeng.com/wiki/896043488029600","categories":[],"tags":[]},{"title":"CSS 外边距重叠及防止方法","slug":"CSS-外边距重叠及防止方法","date":"2019-08-20T08:39:18.000Z","updated":"2019-08-20T08:42:27.214Z","comments":true,"path":"2019/08/20/CSS-外边距重叠及防止方法/","link":"","permalink":"http://yoursite.com/2019/08/20/CSS-外边距重叠及防止方法/","excerpt":"","text":"两个或多个块级盒子的垂直相邻边界会重合。结果的边界宽度是相邻边界宽度中最大的值。如果出现负边界，则在最大的正边界中减去绝对值最大的负边界。如果没有正边界，则从零中减去绝对值最大的负边界。注意：相邻的盒子可能并非是由父子关系或同胞关系的元素生成。 但是边界的重叠也有例外情况： 1、水平边距永远不会重合。 2、在规范文档中，2个或以上的块级盒模型相邻的垂直margin会重叠。最终的margin值计算方法如下： a、全部都为正值，取最大者； b、不全是正值，则都取绝对值，然后用正值减去最大值； c、没有正值，则都取绝对值，然后用0减去最大值。 注意：相邻的盒模型可能由DOM元素动态产生并没有相邻或继承关系。 3、相邻的盒模型中，如果其中的一个是浮动的（float），垂直margin不会重叠，并且浮动的盒模型和它的子元素之间也是这样。 4、设置了overflow属性的元素和它的子元素之间的margin不被重叠（overflow取值为visible除外）。 5、设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，并且和他们的子元素之间也是一样。 6、设置了display:inline-block的元素，垂直margin不会重叠，甚至和他们的子元素之间也是一样。 7、如果一个盒模型的上下margin相邻，这时它的margin可能重叠覆盖（collapse through）它。在这种情况下，元素的位置（position）取决于它的相邻元素的margin是否重叠。 a、如果元素的margin和它的父元素的margin-top重叠在一起，盒模型border-top的边界定义和它的父元素相同。 b、另外，任意元素的父元素不参与margin的重叠，或者说只有父元素的margin-bottom是参与计算的。如果元素的border-top非零，那么元素的border-top边界位置和原来一样。 一个应用了清除操作的元素的margin-top绝不会和它的块级父元素的margin-bottom重叠。 注意，那些已经被重叠覆盖的元素的位置对其他已经重叠的元素的位置没有任何影响；只有在对这些元素的子元素定位时，border-top边界位置才是必需的。 8、根元素的垂直margin不会被重叠。 外边距(margin)重叠示例 外边距重叠是指两个垂直相邻的块级元素，当上下两个边距相遇时，起外边距会产生重叠现象，且重叠后的外边距，等于其中较大者。 图示： 另一个重叠现象是当一个元素包含在另一个元素之中时，子元素与父元素之间也会产生重叠现象，重叠后的外边距，等于其中最大者： CSS 外边距(margin)重叠及防止方法 同理，如果一个无内容的空元素，其自身上下边距也会产生重叠。 CSS 外边距(margin)重叠及防止方法 外边距重叠的意义 外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。 防止外边距重叠解决方案： 虽然外边距的重叠有其一定的意义，但有时候我们在设计上却不想让元素之间产生重叠，那么可以有如下几个建议可供参考： 1234561.外层元素padding代替2.内层元素透明边框 border:1px solid transparent;3.内层元素绝对定位 postion:absolute:4.外层元素 overflow:hidden;5.内层元素 加float:left;或display:inline-block;6.内层元素padding:1px; 以上建议可根据实际情况来采取。","categories":[],"tags":[]},{"title":"笔记3","slug":"笔记3","date":"2019-08-19T00:48:15.000Z","updated":"2019-08-21T08:36:39.186Z","comments":true,"path":"2019/08/19/笔记3/","link":"","permalink":"http://yoursite.com/2019/08/19/笔记3/","excerpt":"","text":"1.设置透明opacity可以设置元素背景的透明，规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 注：opacity属性在IE8及以下的浏览器中不支持，需要使用alpha属性代替，从 0（完全透明）到 100（完全不透明）。 2.图片整合技术当做一个按钮时，有时需要不同的鼠标点击效果，设置伪类切换背景图片从而改变样式。 但是做完功能以后，发现在第一次切换图片时，会发现图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。 产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源。 上面这个练习，起初浏览器只会加载link.png由于hover和active的状态没有马上触发，所以hover.png和active.png并不是立即加载的当hover被触发时，浏览器才去加载hover.png。当active被触发时，浏览器才去加载active.png。 由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况。 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了， 然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术。 优点： 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。 3. 内联元素的盒模型内联元素不能设置width和height。 内联元素可以设置水平方向内边距和边框且可以影响布局； 内联元素可以设置垂直方向内边距和边框但不可以影响布局； 内联元素支持水平方向外边距且可以影响布局； 内联元素不支持垂直方向外边距； 4. display通过display样式可以改变元素的类型 可选值： Inline：此元素会被显示成内联元素。 Block：此元素会被显示成块元素（可换行）。 Inline-block：此元素会被显示成行内块元素（既可以设置宽高也不会换行）。 None：不显示元素，并且元素不会在页面中继续占有位置。 5. overflow子元素默认是存在于父元素的内容区内，理论上讲子元素最大可以等于父元素的内容区大小。 实际如果子元素的大小超过了父元素的内容区，则超过的大小会在父元素以外的位置显示，超出父元素的内容，我们称为溢出的内容。父元素默认是将溢出内容在父元素外显示。 通过overflow可以设置父元素如何处理溢出内容。 可选值： Visible：默认值，不会对溢出内容做处理，元素在父元素内容区外显示。 Hidden：溢出的内容会被修剪，不会显示。 6. clearClear可以用来清除其他浮动元素对当前元素的影响 可选值： none：默认值，不清除浮动。 left：清除左侧浮动元素对当前元素的影响。 right：清除右侧浮动元素对当前元素的影响。 both：清除两侧浮动元素对当前元素的影响。 7.解决高度塌陷方案可以直接在高度塌陷的父元素最后添加一个空白的div，由于这个div没有浮动，所以他是可以撑开父元素的高度的，然后再对其进行清除浮动，这样可以通过空白的div来撑开父元素的高度，基本没有副作用。 这种方式虽然可以解决高度塌陷但是会在HTML中添加多余的结构。 可以通过after伪元素在父元素的最后添加一个空白的元素，然后对其清除浮动。 由于after在元素最后插入生成的内容为行内元素，行内元素不会独占一行，所以需要先使用display将其改为块元素再对其清除浮动。 这样做和添加一个div的原理一样，可以达到相同的效果，而且不会再页面中添加多余的div，几乎没有副作用，这是最推荐的解决高度塌陷问题的方式。 例： 12345678910.box1:after&#123; /*添加一个内容*/ content:\"\"; /*转换为一个块元素*/ display:block; /*清除两侧的浮动*/ clear:both; &#125; 8.表单表单用于收集用户输入，表单的作用就是用来将用户信息提交给服务器的。比如：百度的搜索框 注册 登录这些操作都需要填写表单。 8.1 action属性action属性定义在提交表单时执行的动作。使用form标签创建一个表单，form标签中必须指定一个action属性，该属性指向的是一个服务器的地址。当我们提交表单时将会提交到action属性对应的地址，向服务器提交表单的通常做法是使用提交按钮。 1&lt;form action=&quot;action_page.php&quot;&gt; 8.2 method属性method属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）： 1&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt; 或： 1&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt; 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。 当使用 GET 时，表单数据在页面地址栏中是可见的。 注：GET 最适合少量数据的提交。浏览器会设定容量限制。 应该使用 POST： 如果表单正在更新数据，或者包含敏感信息（例如密码）。 POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 8.3 文本输入&lt; input type=”text”&gt; 定义用于文本输入的单行输入字段。使用input来创建一个文本框，它的type属性是text。 8.4 提交按钮&lt; input type=”submit”&gt;定义用于向表单处理程序（form-handler）提交表单的按钮。 表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。表单处理程序在表单的 action 属性中指定。 8.5 name属性如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性，name表示提交内容的名字。 8.6 用 fieldset 组合表单数据fieldset 元素组合表单中的相关数据 legend 元素为 fieldset元素定义标题。 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset 中。在fieldset可以使用legend子标签，来指定组名。 其余表单内容详见：https://www.w3school.com.cn/html/html_form_elements.asp","categories":[],"tags":[]},{"title":"笔记2","slug":"笔记2","date":"2019-08-17T01:56:17.000Z","updated":"2019-08-17T12:51:15.374Z","comments":true,"path":"2019/08/17/笔记2/","link":"","permalink":"http://yoursite.com/2019/08/17/笔记2/","excerpt":"","text":"1.定位通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。 position 属性值的含义： 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素（离他最近的开启了定位的祖先元素）进行定位。元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。（会固定在浏览器窗口某个位置，不会随浏览器滚动条滚动）。 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。相对定位会使元素提升一个层级。 因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 2.层级如果定位元素层级一样，html中下边的元素会盖住上面的元素。 z-index通过z-index属性可以设置元素的层级，层级越高，显示离用户越近。（z-index 仅能在定位元素上奏效）","categories":[],"tags":[]},{"title":"笔记1","slug":"笔记1","date":"2019-08-16T08:56:45.000Z","updated":"2019-08-16T08:57:37.854Z","comments":true,"path":"2019/08/16/笔记1/","link":"","permalink":"http://yoursite.com/2019/08/16/笔记1/","excerpt":"","text":"Ajax理解Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。比如在知乎页面中将鼠标悬停到标签上时创建一个新的小窗口，用js向知乎服务器发送一个请求，得到这个小窗口应该显示的数据，放在这个小窗口里，这就是所谓的Ajax，不用刷新就能与服务器进行交互，更新页面的一小部分。例如，门户网站的新闻列表，可能1个小时之内，服务器后台已增加了很多条新的新闻，前端可以通过刷新，从新获取最新的新闻展示在页面上。 再如，网页文字直播NBA篮球比赛，可能后台服务器每几秒就会有一条新的动态，需要用户连续刷新页面内容来获取最新动态。以上的刷新方法是用户手动对整个页面内容进行刷新，针对以上的需求，明显是不合理的，AJAX就是实现了自动更新需要刷新的数据的效果。其基本思路是前端js与后台不断通讯,及时获取前端某部分数据的变化信息,及时进行自动数据获取更新,使用户无需刷新网页即可保持页面数据最新的状态。例如，球赛文字直播、股票实时信息等。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-16T06:41:27.267Z","updated":"2019-08-16T06:41:27.267Z","comments":true,"path":"2019/08/16/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}